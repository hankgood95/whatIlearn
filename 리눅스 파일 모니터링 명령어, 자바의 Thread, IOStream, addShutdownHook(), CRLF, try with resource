리눅스 watch 명령어

리눅스에서 watch 명령어는 특정 명령어를 원하는 시간 주기로 반복시켜주는 명령어이다.
watch에는 여러 옵션들이 있는데 아마 주로 사용할것으로 예상되는것은
d와n이다.

d 옵션은 이전 출력 결과와 비교하여 다른 부분을 하이라이트 쳐주는 부분이고
n 옵션은 입력한 명령어의 결과를 몇초 단위로 계속 호출하는것이다.


ex)
watch -n1 ls -alh 파일명
특정 디렉을 1초마다 ls하여서 확인하라는 뜻

----------------------------------------------------------------------------------------------------------------

리눅스 ls 의 유용한 옵션들

-a : 안보이는 파일들까지 보여주는것
-l : 파일 권한 정보까지 모두 보여주는것
-lh : 파일을 사람이 보기 편한 방식으로 보여주는것. 이 있다.

----------------------------------------------------------------------------------------------------------------

리눅스에서 의 ~ 사용 주의사항
※ ~ 하고 입력을 하게 된다면 ~ 의 경로는 계정에따라 달라진다. 그래서 다른계정을 들어가고 싶을땐 ~를 쓰면 안되지만 
해당 계정에서의 경로를 알고 싶을때는 ~/ 를 쓰면 home까지의 경로를 굳이 칠필요가 없다.

----------------------------------------------------------------------------------------------------------------

리눅스에서 특정 파일의 라인개수를 확인해보고 싶을때는 wc -1 파일명 을 입력을 하면 해당 파일의 라인 개수를 확인해볼수 있다.

----------------------------------------------------------------------------------------------------------------

자바에서 Thread를 작성하는 2가지 방법

1. Thread 클래스 확장하기

Thread 클래스를 extends 해서 run()을 오버라이드해서 사용하면 된다.

2. Runnable 인터페이스 구현하기
Thread와 동일한 기능을 하지만 extends Thread를 implements Runnable로 바뀐것이다.


이둘이 같은 기능을 하는것이라면 둘의 차이가 무엇일까?

둘의 차이는 일단 Thread는 extends를 받기 때문에 다중상속이 불가능하다.
하지만 Runnable은 implements이기 때문에 다른 인터페이스를 구현할수도 잇고 심지어는 다른 클래스를 상속 받을수도 있다.


----------------------------------------------------------------------------------------------------------------

Runtime.getRuntime().addShutdownHook() 의 의미
해당 의미는 일단 JVM 런타임에 새 스레드를 등록하는데 사용된다.
따라서 addShutdownHook() 안에 있는것으로 스레드를 등록을 하는것이다.

그럼 당연히 () 안에는 Thread 객체가 있어야 한다.

----------------------------------------------------------------------------------------------------------------

::stop은 무슨 의미일까
일단 ::는 기존 메소드를 호출하는 람다식 약어이다. 
구렇다면 앞에 참조하는 AppRefactored.this의 stop을 호출한다는 얘기이다.

----------------------------------------------------------------------------------------------------------------

FilenameUtils.concat() 뜻

공식 문서에 따르면 아래와같은 파라미터를 입력을 받는다고 한다.
concat(String basePath, String fullFileNameToAdd)
이건 basePath,파일명 이렇게 받아서 새로운 파일 경로를 만들어주는것이다.
비슷한 역할을 하는걸 찾아본다면 Path.gets("경로","경로")
이렇게 해서 앞의 경로들을 가지고 새로운 파일 경로를 만들어 주는것이다.

----------------------------------------------------------------------------------------------------------------

Java의 입출력

java에서의 입출력은 Stream을 통해 이루어진다.
여기서 stream이란 데이터를 운반하는데 연결 통로이다.
stream은 영어단어 뜻으로는 물길? 을 뜻하는데 데이터가 한쪽으로만 이동된다는 뜻으로 이해해도 무방하다.
무튼간데 Stream을 통해서 데이터를 주고 받게 된다.

InputStream과 OutputStream은 위의 Stream의 개념에서 input과 output을 섞은것이다.
InputStream은 데이터가 들어오는 Stream을 뜻하고 OutputStream은 데이터가 나가는 stream을 뜻한다.

InputStream과 OutputStream 을 상속 받는 클래스는 아래와 같이 있다.

1. FileInputStream/FileOutputStream
2. ByteArrayInputStream/ByteArrayOutputStream
3. PipedInputStream/PipedOutputStream

I/O Stream을 상속 받는 클래스들은 모두 입출력 단위가 byte라는것이 가장 중요한 점이다.

I/O Stream의 문제점으로는 문자를 처리하기 어렵다는것이 단점이다. 그래서 Java에서 이를 보완하기 위해서
Reader와 I/OStreamWriter가 있다.
얘네는 문자를 보내기 위해서 만든것이므로 데이터를 char 형식으로 데이터를 주고받는다 따라서 2byte 씩 보내게 된다.
문자를 보내는데에는 편할수있겠지만 불편한점이 있다면 문자이기 때문에 인코딩 정보가 필요하다.

이렇게 Stream 방식은 하나하나씩 데이터를 보내는것이 가장 큰 특징이다.
데이터를 하나하니씩 보내게 되는데 이게 가끔씩은 느리게 느껴질때가 있다.
어떤경우냐면 게임처럼 대용량 데이터를 주고 받을때 데이터를 하나하니씩 받게 되면 즉 입력이 출력보다 빠를때 
한개한개씩 받게 되면 전송시간이 너무 느려지게 된다. 따라서 이를 보완하기 위해서 또 만든 방식이 Buffered 방식이다.

Buffered 방식이란?
Buffered 방식은 Stream 방식과 똑같지만 여기서 Buffer라는 특정한 공간에서 데이터를 모아놨다가 어느 임계치가 되면
쌓인 데이터를 한꺼번에 보내게 되는것이다. 이래서 대용량 데이터의 전송에는 Buffered가 적절한 것이다.


Buffered도 Stream과 똑같이 Input과 Output이 따로 있고 문자를 보완하기 위해서 BufferedReader와 BufferedReader가 있다.

----------------------------------------------------------------------------------------------------------------

CR/LF 란?

CR은 현재 줄에서 커서의 위치를 맨앞으로 옮기는 동작을 말한다.

LF는 현재 커서의 위치에서 하나의 줄을 아래로 이동하는것이다. 여기서 중요한것음 커서 위치 변화없이 커서를 내리는것이다.

----------------------------------------------------------------------------------------------------------------

이클립스에서 변수를 클릭했을때 같은 변수를 하이라이트 쳐주게 하는 방법은 

Window -> Preference -> Java -> Editor -> Mark Occurrences 에 들어가서
Mark occurences of the selected element in the current file을 체크해주면 된다.

----------------------------------------------------------------------------------------------------------------

try with resources 란?
try with resource란 자원을 관리하기 쉽게 만들기 위한 것이다.
우리가 파일 핸들링을 할때 try-catch 구문에서 stream 관련된것은 finally{} 구문에서 무조건적으로 닫게해준 소스를 본적이 있을것이다.
이걸 관리하기 쉽게하기 위해서 만든것이 try with resource이다. 
Closable 이라는 인터페이스를 구현 받는 객체라면 아래와 같이 만들어서 사용하게 되면 
따로 close()를 해주지 않더라고 저절로 close()가 된다.
try(FileOutputStream fos = new FileOutputStream()){

}catch(Exception e){}

그렇다고 try with resource 구문이 편하니까 무조건적으로 이것만 쓰는것은 아니다. Graceful하게 쓰레드나 프로세스를 종료 시키고 싶을땐
finally{} 구문을 사용하여서 종료 프로세스를 실행시키면 된다.
